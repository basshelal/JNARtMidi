package dev.basshelal.jnartmidi.lib

import com.sun.jna.Callback
import com.sun.jna.IntegerType
import com.sun.jna.Library
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.ptr.ByReference
import java.nio.ByteBuffer

// JNAerator command used:
// java -jar jnaerator.jar -library rtmidi rtmidi_c.h librtmidi.so -o . -v -noJar -noComp -f -runtime JNA

/**
 * Wraps RtMidi's C interface, autogenerated by JNAerator with manual adjustments
 * [RtMidi C interface documentation](https://www.music.mcgill.ca/~gary/rtmidi/group__C-interface.html).
 *
 * Implementation found in [RtMidiLibraryNative] where the methods are "implemented"
 * using the `native` keyword.
 *
 * To use the library use [RtMidiLibrary.getInstance].
 *
 * @author Bassam Helal
 */
interface RtMidiLibrary : Library {

    companion object {
        const val LIBRARY_NAME = "rtmidi"

        /**
         * @return A usable [RtMidiLibrary] instance
         */
        @JvmStatic
        val instance: RtMidiLibrary
            get() = RtMidiLibraryNative.instance
    }

    //=============================================================================================
    //====================================     Types     ==========================================
    //=============================================================================================
    /**
     * ! \brief MIDI API specifier arguments.  See \ref RtMidi::Api.<br></br>
     * *native declaration : rtmidi_c.h:23*<br></br>
     * enum values
     */
    interface RtMidiApi {
        companion object {
            /**
             * < Search for a working compiled API.<br></br>
             * *native declaration : rtmidi_c.h:16*
             */
            const val RTMIDI_API_UNSPECIFIED = 0

            /**
             * < Macintosh OS-X CoreMIDI API.<br></br>
             * *native declaration : rtmidi_c.h:17*
             */
            const val RTMIDI_API_MACOSX_CORE = 1

            /**
             * < The Advanced Linux Sound Architecture API.<br></br>
             * *native declaration : rtmidi_c.h:18*
             */
            const val RTMIDI_API_LINUX_ALSA = 2

            /**
             * < The Jack Low-Latency MIDI Server API.<br></br>
             * *native declaration : rtmidi_c.h:19*
             */
            const val RTMIDI_API_UNIX_JACK = 3

            /**
             * < The Microsoft Multimedia MIDI API.<br></br>
             * *native declaration : rtmidi_c.h:20*
             */
            const val RTMIDI_API_WINDOWS_MM = 4

            /**
             * < A compilable but non-functional API.<br></br>
             * *native declaration : rtmidi_c.h:21*
             */
            const val RTMIDI_API_RTMIDI_DUMMY = 5

            /**
             * < Number of values in this enum.<br></br>
             * *native declaration : rtmidi_c.h:22*
             */
            const val RTMIDI_API_NUM = 6
        }
    }

    /**
     * ! \brief Defined RtMidiError types. See \ref RtMidiError::Type.<br></br>
     * *native declaration : rtmidi_c.h:37*<br></br>
     * enum values
     */
    interface RtMidiErrorType {
        companion object {
            /**
             * < A non-critical error.<br></br>
             * *native declaration : rtmidi_c.h:26*
             */
            const val RTMIDI_ERROR_WARNING = 0

            /**
             * < A non-critical error which might be useful for debugging.<br></br>
             * *native declaration : rtmidi_c.h:27*
             */
            const val RTMIDI_ERROR_DEBUG_WARNING = 1

            /**
             * < The default, unspecified error type.<br></br>
             * *native declaration : rtmidi_c.h:28*
             */
            const val RTMIDI_ERROR_UNSPECIFIED = 2

            /**
             * < No devices found on system.<br></br>
             * *native declaration : rtmidi_c.h:29*
             */
            const val RTMIDI_ERROR_NO_DEVICES_FOUND = 3

            /**
             * < An invalid device ID was specified.<br></br>
             * *native declaration : rtmidi_c.h:30*
             */
            const val RTMIDI_ERROR_INVALID_DEVICE = 4

            /**
             * < An error occured during memory allocation.<br></br>
             * *native declaration : rtmidi_c.h:31*
             */
            const val RTMIDI_ERROR_MEMORY_ERROR = 5

            /**
             * < An invalid parameter was specified to a function.<br></br>
             * *native declaration : rtmidi_c.h:32*
             */
            const val RTMIDI_ERROR_INVALID_PARAMETER = 6

            /**
             * < The function was called incorrectly.<br></br>
             * *native declaration : rtmidi_c.h:33*
             */
            const val RTMIDI_ERROR_INVALID_USE = 7

            /**
             * < A system driver error occured.<br></br>
             * *native declaration : rtmidi_c.h:34*
             */
            const val RTMIDI_ERROR_DRIVER_ERROR = 8

            /**
             * < A system error occured.<br></br>
             * *native declaration : rtmidi_c.h:35*
             */
            const val RTMIDI_ERROR_SYSTEM_ERROR = 9

            /**
             * < A thread error occured.<br></br>
             * *native declaration : rtmidi_c.h:36*
             */
            const val RTMIDI_ERROR_THREAD_ERROR = 10
        }
    }

    /**
     * typedef void(* RtMidiCCallback) (double timeStamp, const unsigned char* message, size_t messageSize, void* userData);
     * *native declaration : rtmidi_c.h:45*
     */
    interface RtMidiCCallback : Callback {
        // RealTimeCritical
        operator fun invoke(timeStamp: Double, message: Pointer?, messageSize: NativeSize?, userData: Pointer?)
    }

    /**
     * 'size_t' C type (32 bits on 32 bits platforms, 64 bits on 64 bits platforms).
     * Can be also used to model the 'long' C type for libraries known to be compiled with GCC or LLVM even on Windows.
     * (NativeLong on Windows is only okay with MSVC++ libraries, as 'long' on Windows 64 bits will be 32 bits with MSVC++ and 64 bits with GCC/mingw)
     *
     * @author ochafik
     */
    class NativeSize
    @JvmOverloads constructor(value: Long = 0) : IntegerType(SIZE, value) {
        companion object {
            /**
             * Size of a size_t integer, in bytes.
             */
            var SIZE = Native.SIZE_T_SIZE // Platform.is64Bit() ? 8 : 4;
        }

        override fun toByte(): Byte {
            TODO("Not yet implemented")
        }

        override fun toChar(): Char {
            TODO("Not yet implemented")
        }

        override fun toShort(): Short {
            TODO("Not yet implemented")
        }
    }

    /**
     * Like [NativeSize] but passed by reference, ie in C code size_t *
     */
    class NativeSizeByReference(value: NativeSize) : ByReference(NativeSize.SIZE) {
        @JvmOverloads
        constructor(value: Int = 0) : this(NativeSize(value.toLong()))

        var value: NativeSize
            get() = if (NativeSize.SIZE == 4) NativeSize(pointer.getInt(0).toLong()) else if (NativeSize.SIZE == 8) NativeSize(pointer.getLong(0)) else throw RuntimeException("GCCLong has to be either 4 or 8 bytes.")
            set(value) {
                if (NativeSize.SIZE == 4) pointer.setInt(0, value.toInt()) else if (NativeSize.SIZE == 8) pointer.setLong(0, value.toLong()) else throw RuntimeException("GCCLong has to be either 4 or 8 bytes.")
            }

        init {
            this.value = value
        }
    }

    class RtMidiInPtr : RtMidiPtr()
    class RtMidiOutPtr : RtMidiPtr()
    //=============================================================================================
    //=================================     RtMidi API     ========================================
    //=============================================================================================
    /**
     * Determine the available compiled MIDI APIs.
     * If the given `apis` parameter is `null`, returns the number of available APIs.
     * Otherwise, fill the given `apis` array with the [RtMidiApi] values.<br></br>
     *
     * Original signature : `int rtmidi_get_compiled_api(RtMidiApi*, unsigned int)`
     *
     * @param apis      An array to be filled or a null, ensure the array is at least
     * [RtMidiApi.RTMIDI_API_NUM] in size.
     * @param apis_size size of the passed in array `apis`, ignored if `apis` is `null`
     * @return number of items needed for `apis` array if `apis == null`, or
     * number of items written to `apis` array otherwise.
     * A negative return value indicates an error.
     */
    fun rtmidi_get_compiled_api(apis: IntArray, apis_size: Int): Int

    /**
     * ! See \ref RtMidi::getApiName().<br></br>
     * Original signature : `char* rtmidi_api_name(RtMidiApi)`<br></br>
     * *native declaration : rtmidi_c.h:63*
     */
    fun rtmidi_api_name(api: Int): String

    /**
     * ! See \ref RtMidi::getApiDisplayName().<br></br>
     * Original signature : `char* rtmidi_api_display_name(RtMidiApi)`<br></br>
     * *native declaration : rtmidi_c.h:68*
     */
    fun rtmidi_api_display_name(api: Int): String

    /**
     * ! See \ref RtMidi::getCompiledApiByName().<br></br>
     * Original signature : `RtMidiApi rtmidi_compiled_api_by_name(const char*)`<br></br>
     * *native declaration : rtmidi_c.h:73*
     */
    fun rtmidi_compiled_api_by_name(name: String): Int

    /**
     * \brief Open a MIDI port.<br></br>
     * \param port      Must be greater than 0<br></br>
     * \param portName  Name for the application port.<br></br>
     * See RtMidi::openPort().<br></br>
     * Original signature : `void rtmidi_open_port(RtMidiPtr, unsigned int, const char*)`<br></br>
     * *native declaration : rtmidi_c.h:86*
     */
    fun rtmidi_open_port(device: RtMidiPtr, portNumber: Int, portName: String)

    /**
     * \brief Creates a virtual MIDI port to which other software applications can <br></br>
     * connect.  <br></br>
     * \param portName  Name for the application port.<br></br>
     * See RtMidi::openVirtualPort().<br></br>
     * Original signature : `void rtmidi_open_virtual_port(RtMidiPtr, const char*)`<br></br>
     * *native declaration : rtmidi_c.h:94*
     */
    fun rtmidi_open_virtual_port(device: RtMidiPtr, portName: String)

    /**
     * \brief Close a MIDI connection.<br></br>
     * See RtMidi::closePort().<br></br>
     * Original signature : `void rtmidi_close_port(RtMidiPtr)`<br></br>
     * *native declaration : rtmidi_c.h:100*
     */
    fun rtmidi_close_port(device: RtMidiPtr)

    /**
     * \brief Return the number of available MIDI ports.<br></br>
     * See RtMidi::getPortCount().<br></br>
     * Original signature : `int rtmidi_get_port_count(RtMidiPtr)`<br></br>
     * *native declaration : rtmidi_c.h:106*
     */
    fun rtmidi_get_port_count(device: RtMidiPtr): Int

    /**
     * \brief Return a string identifier for the specified MIDI input port number.<br></br>
     * See RtMidi::getPortName().<br></br>
     * Original signature : `char* rtmidi_get_port_name(RtMidiPtr, unsigned int)`<br></br>
     * *native declaration : rtmidi_c.h:112*
     */
    fun rtmidi_get_port_name(device: RtMidiPtr, portNumber: Int): String
    //=============================================================================================
    //===============================     RtMidiIn API     ========================================
    //=============================================================================================
    /**
     * Create a default [RtMidiInPtr] value, with no initialization, RtMidi will choose its own API and
     * client name, to set these yourself use [.rtmidi_in_create]
     * Original signature : `RtMidiInPtr rtmidi_in_create_default()`
     */
    fun rtmidi_in_create_default(): RtMidiInPtr

    /**
     * Create a [RtMidiInPtr] value, with given api, clientName and queueSizeLimit.
     * Original signature : `RtMidiInPtr rtmidi_in_create(RtMidiApi, const char*, unsigned int)`<br></br>
     *
     * @param api            An [RtMidiApi] to use or 0 ie [RtMidiApi.RTMIDI_API_UNSPECIFIED]
     * to let RtMidi choose the first suitable API
     * @param clientName     Non null client name, this will be used to group the ports that are created by the
     * application.
     * @param queueSizeLimit Size of the MIDI input queue, negative values are not allowed and 0 may cause segfaults
     * later on, this allocates a queue of this size so keep it reasonable.
     */
    // TODO: 22/02/2021 queueSizeLimit is bad...
    //  basically, it cannot be null (even if using Pointer), cannot be 0 because segfault later and
    //  if a small number, the message queue limit will be reached which floods our output with error messages saying
    //  MidiInAlsa: message queue limit reached!!
    //  using rtmidi_in_create_default() will give a queueSizeLimit of 100
    //  this is regardless of anything because there is a midi message handler created by the library that pushes
    //  to the queue and if the queue is full, will output errors,
    //  Using a large number to avoid flooding is a bad idea because that memory is allocated
    //  The only thing we can do is allow it to flood our output, a solution would be to have the error logging be
    //  conditional in the C++ code so that a version can be built where this will be silent
    fun rtmidi_in_create(api: Int, clientName: String, queueSizeLimit: Int): RtMidiInPtr

    /**
     * Free the given [RtMidiInPtr].
     * After this operation using the `RtMidiInPtr` in any way within the RtMidi library
     * (ie [.rtmidi_close_port]) will cause a fatal VM error as a result of a segfault in the native code.
     * It is only safe to query the struct's data such as [RtMidiPtr.ok] or [RtMidiPtr.getPointer] etc.
     * Original signature : `void rtmidi_in_free(RtMidiInPtr)`<br></br>
     *
     * @param device the [RtMidiInPtr] to free
     */
    fun rtmidi_in_free(device: RtMidiInPtr)

    /**
     * ! See \ref RtMidiIn::getCurrentApi().<br></br>
     * Original signature : `RtMidiApi rtmidi_in_get_current_api(RtMidiPtr)`<br></br>
     * *native declaration : rtmidi_c.h:139*
     */
    fun rtmidi_in_get_current_api(device: RtMidiInPtr): Int

    /**
     * ! See \ref RtMidiIn::setCallback().<br></br>
     * Original signature : `void rtmidi_in_set_callback(RtMidiInPtr, RtMidiCCallback, void*)`<br></br>
     * *native declaration : rtmidi_c.h:144*
     */
    fun rtmidi_in_set_callback(device: RtMidiInPtr, callback: RtMidiCCallback, userData: Pointer)

    /**
     * ! See \ref RtMidiIn::cancelCallback().<br></br>
     * Original signature : `void rtmidi_in_cancel_callback(RtMidiInPtr)`<br></br>
     * *native declaration : rtmidi_c.h:149*
     */
    fun rtmidi_in_cancel_callback(device: RtMidiInPtr)

    /**
     * ! See \ref RtMidiIn::ignoreTypes().<br></br>
     * Original signature : `void rtmidi_in_ignore_types(RtMidiInPtr, bool, bool, bool)`<br></br>
     * *native declaration : rtmidi_c.h:154*
     */
    fun rtmidi_in_ignore_types(device: RtMidiInPtr, midiSysex: Boolean, midiTime: Boolean, midiSense: Boolean)

    /**
     * Fill the user-provided array with the data bytes for the next available<br></br>
     * MIDI message in the input queue and return the event delta-time in seconds.<br></br>
     * \param message   Must point to a char* that is already allocated.<br></br>
     * SYSEX messages maximum size being 1024, a statically<br></br>
     * allocated array could<br></br>
     * be sufficient. <br></br>
     * \param size      Is used to return the size of the message obtained. <br></br>
     * See RtMidiIn::getMessage().<br></br>
     * Original signature : `double rtmidi_in_get_message(RtMidiInPtr, unsigned char*, size_t*)`<br></br>
     * *native declaration : rtmidi_c.h:166*
     */
    fun rtmidi_in_get_message(device: RtMidiInPtr, message: ByteBuffer, size: NativeSizeByReference): Double
    //=============================================================================================
    //================================     RtMidiOut API     ======================================
    //=============================================================================================
    /**
     * ! \brief Create a default RtMidiInPtr value, with no initialization.<br></br>
     * Original signature : `RtMidiOutPtr rtmidi_out_create_default()`<br></br>
     * *native declaration : rtmidi_c.h:171*
     */
    fun rtmidi_out_create_default(): RtMidiOutPtr

    /**
     * \brief Create a RtMidiOutPtr value, with given and clientName.<br></br>
     * \param api            An optional API id can be specified.<br></br>
     * \param clientName     An optional client name can be specified. This<br></br>
     * will be used to group the ports that are created<br></br>
     * by the application.<br></br>
     * See RtMidiOut::RtMidiOut().<br></br>
     * Original signature : `RtMidiOutPtr rtmidi_out_create(RtMidiApi, const char*)`<br></br>
     * *native declaration : rtmidi_c.h:181*
     */
    fun rtmidi_out_create(api: Int, clientName: String): RtMidiOutPtr

    /**
     * Free the given [RtMidiOutPtr].
     * After this operation using the `RtMidiOutPtr` in any way within the RtMidi library
     * (ie [.rtmidi_close_port]) will cause a fatal VM error as a result of a segfault in the native code.
     * It is only safe to query the struct's data such as [RtMidiPtr.ok] or [RtMidiPtr.getPointer] etc.
     * Original signature : `void rtmidi_out_free(RtMidiOutPtr)`<br></br>
     *
     * @param device the [RtMidiOutPtr] to free
     */
    fun rtmidi_out_free(device: RtMidiOutPtr)

    /**
     * ! See \ref RtMidiOut::getCurrentApi().<br></br>
     * Original signature : `RtMidiApi rtmidi_out_get_current_api(RtMidiPtr)`<br></br>
     * *native declaration : rtmidi_c.h:191*
     */
    fun rtmidi_out_get_current_api(device: RtMidiOutPtr): Int

    /**
     * ! See \ref RtMidiOut::sendMessage().<br></br>
     * Original signature : `int rtmidi_out_send_message(RtMidiOutPtr, const unsigned char*, int)`<br></br>
     * *native declaration : rtmidi_c.h:196*
     */
    fun rtmidi_out_send_message(device: RtMidiOutPtr, message: ByteArray, length: Int): Int

}